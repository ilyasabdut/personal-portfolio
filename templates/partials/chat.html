<div x-data="chatStream()" class="chat-box">
  <div class="chat-header" @click="toggleChat">
    <h3 class="chat-title">Ask Me!</h3>
    <button id="chat-toggle-btn" class="chat-toggle-btn">üóñ</button>
  </div>

  <div id="chat-body" class="chat-body" style="display: none;">
    <div id="messages" class="chat-messages" x-ref="messages">
      <template x-for="msg in messages" :key="msg.id">
        <div class="bubble" :class="msg.type" :id="'msg-' + msg.id">
          <template x-if="msg.content === 'typing...'">
            <div class="dot-typing">
              <span></span>
              <span></span>
              <span></span>
            </div>
          </template>
          <template x-if="msg.content !== 'typing...'">
            <span x-text="msg.content"></span>
          </template>
        </div>
      </template>
    </div>

    <!-- Chat input moved inside the chat body -->
    <form @submit.prevent="sendMessage" class="chat-form">
      <input x-model="input" type="text" placeholder="Type your message..." required class="chat-input" />
    </form>
  </div>
</div>

<script>
  function chatStream() {
    return {
      input: '',
      messages: [],
      eventSource: null,
      
      toggleChat() {
        const body = document.getElementById("chat-body");
        const btn = document.getElementById("chat-toggle-btn");
        const isHidden = body.style.display === "none";
        body.style.display = isHidden ? "block" : "none";
        btn.textContent = isHidden ? "_" : "üóñ";
      },
      
      sendMessage() {
        const msg = this.input.trim();
        if (!msg) return;

        this.input = '';
        const userId = Date.now();
        this.messages.push({ id: userId, type: 'user-bubble', content: msg });

        this.$nextTick(() => {
          requestAnimationFrame(() => {
            this.$refs.messages.scrollTop = this.$refs.messages.scrollHeight;
          });
        });

        const llmId = userId + 1;
        this.messages.push({ id: llmId, type: 'llm-bubble', content: 'typing...' });
        
        // Close any existing connection
        if (this.eventSource) {
          this.eventSource.close();
        }
        
        // Setup SSE connection
        const queryParams = new URLSearchParams({ message: msg }).toString();
        this.eventSource = new EventSource(`/chat?${queryParams}`);
        
        let llmMsg = '';
        let typingCleared = false;
        
        this.eventSource.onmessage = (event) => {
          const chunk = event.data;
          llmMsg += decodeHTML(chunk);
          
          const msgObj = this.messages.find(m => m.id === llmId);
          
          if (!typingCleared && msgObj.content === 'typing...') {
            msgObj.content = '';
            typingCleared = true;
          }
          
          msgObj.content = decodeHTML(llmMsg);
          
          this.$nextTick(() => {
            requestAnimationFrame(() => {
              const last = document.getElementById(`msg-${llmId}`);
              last?.scrollIntoView({ behavior: 'auto' });
            });
          });
        };
        
        this.eventSource.addEventListener('complete', () => {
          this.eventSource.close();
        });
        
        this.eventSource.addEventListener('error', (event) => {
          console.error("SSE error:", event);
          const msgObj = this.messages.find(m => m.id === llmId);
          if (msgObj.content === 'typing...') {
            msgObj.content = "‚ö†Ô∏è Network error. Try again.";
          }
          this.eventSource.close();
        });
      }
    }
  }

  function decodeHTML(html) {
    const txt = document.createElement("textarea");
    txt.innerHTML = html;
    return txt.value;
  }
</script>